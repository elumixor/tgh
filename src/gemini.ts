import { GoogleGenAI, type PersonGeneration } from "@google/genai";
import { env } from "./env";

export interface GenerateImageParams {
  prompt: string;
  aspectRatio?: "1:1" | "3:4" | "4:3" | "9:16" | "16:9";
  numberOfImages?: 1 | 2 | 3 | 4;
  personGeneration?: PersonGeneration;
}

export interface EditImageParams {
  prompt: string;
  referenceImages: string[];
  aspectRatio?: "1:1" | "3:4" | "4:3" | "9:16" | "16:9";
}

interface GeminiImagePart {
  inlineData: {
    mimeType: string;
    data: string;
  };
}

export class GeminiClient {
  private client: GoogleGenAI;
  private model = "imagen-3.0-generate-002";

  constructor(apiKey?: string) {
    if (!apiKey && !env.GEMINI_API_KEY) throw new Error("GEMINI_API_KEY is required");
    this.client = new GoogleGenAI({ apiKey: apiKey || env.GEMINI_API_KEY });
  }

  async generateImage(params: GenerateImageParams): Promise<string[]> {
    const response = await this.client.models.generateImages({
      model: this.model,
      prompt: params.prompt,
      config: {
        aspectRatio: params.aspectRatio || "1:1",
        numberOfImages: params.numberOfImages || 1,
        ...(params.personGeneration && {
          personGeneration: params.personGeneration,
        }),
      },
    });

    const images: string[] = [];

    if (response.generatedImages) {
      for (const img of response.generatedImages) {
        if (img.image?.imageBytes) images.push(img.image.imageBytes);
      }
    }

    if (images.length === 0) throw new Error("No images generated by Gemini API");

    return images;
  }

  async editImage(params: EditImageParams): Promise<string> {
    const imageParts: (GeminiImagePart | { text: string })[] = [];

    for (const imageUrl of params.referenceImages) {
      const imagePart = await this.urlToImagePart(imageUrl);
      imageParts.push(imagePart);
    }

    imageParts.push({ text: params.prompt });

    const response = await this.client.models.generateContent({
      model: this.model,
      contents: imageParts,
      config: {
        responseModalities: ["image"],
        ...(params.aspectRatio && {
          outputImageAspectRatio: params.aspectRatio,
        }),
      },
    });

    if (response.candidates?.[0]?.content?.parts) {
      for (const part of response.candidates[0].content.parts) {
        if (part.inlineData?.data) return part.inlineData.data;
      }
    }

    throw new Error("No image generated by Gemini API");
  }

  private async urlToImagePart(url: string): Promise<GeminiImagePart> {
    const response = await fetch(url);
    if (!response.ok) throw new Error(`Failed to fetch image from URL: ${response.status}`);

    const arrayBuffer = await response.arrayBuffer();
    const base64 = Buffer.from(arrayBuffer).toString("base64");

    let mimeType = response.headers.get("content-type") || "image/jpeg";

    if (mimeType === "application/octet-stream" || !mimeType.startsWith("image/")) {
      if (url.includes(".png")) mimeType = "image/png";
      else if (url.includes(".webp")) mimeType = "image/webp";
      else mimeType = "image/jpeg";
    }

    return { inlineData: { mimeType, data: base64 } };
  }

  base64ToBuffer(base64: string): Uint8Array {
    return Buffer.from(base64, "base64");
  }
}
